/* Copyright 1990-2007, Jsoftware Inc.  All rights reserved.               */
/* Licensed use only. Any other use is in violation of copyright.          */
/*                                                                         */
/* Type Definitions                                                        */

#define U unsigned

#if (SYS & SYS_UNIX)
#define _stdcall      
#endif

#if defined(__GNUC__)
#define CDPROC __attribute__ ((visibility ("default")))
#else
#define CDPROC
#endif

typedef long long          A1;
typedef unsigned long long BT;
typedef long long          I;
typedef long long          SB;
typedef unsigned long long UI;
typedef unsigned long long UIL;   /* for typecast 8 byte double */
typedef long long          IL;
//NANFLAG is used internally as a special value that is not generated by any normal operations.  It is represented in integer form,
// and is used only when SZI==SZD
#define NANFLAG 0x7ff28da91LL  // signaling NaN with a particular value

typedef char               B;
typedef unsigned char      C;
typedef char*              Ptr;
typedef short              S; // short
typedef short              C2;
typedef unsigned int       C4;
typedef unsigned char      UC;
typedef unsigned short     US;
typedef unsigned short     U2;
typedef unsigned int       UINT;
typedef int                I4;
typedef unsigned int       UI4;
typedef double             D; // double
//typedef float              DS; // Robert R? double single
                               // Lesley L? shrank double
                               // Conor H? d??? single
                               // Alexandre B? decimal single precision
                               // Shubham S? short double
typedef FILE*              F;

typedef long double        LD;

// This is the main structure for J entities
typedef US                 RANKT;
#define RANKTX             16   // # bits in a RANKT
#define RANKTMSK           (((I)1<<RANKTX)-1)
#define R2MAX              ((RMAX<<RANKTX)+RMAX)  // max value of a RANK2T
typedef UI4                RANK2T;  // 2 ranks, (l<<16)|r
#define RANK2TX            32   // # bits in a RANK2T
#define RANK2TMSK           0xFFFFFFFFU
typedef I                  FLAGT;
typedef UI4                LX;  // index of an L block in LAV0(jt->symp)

typedef struct AD AD;
typedef AD *A;

// Flag bits in the low-order part of jt - used only if the function being called understands inplacing
#define JTINPLACEWX     0   // turn this on in jt to indicate that w can be inplaced
#define JTINPLACEW      (((I)1)<<JTINPLACEWX)
#define JTINPLACEAX     1   // turn this on in jt to indicate that a can be inplaced.  Must be 1+JTINPLACEWX
#define JTINPLACEA      (((I)1)<<JTINPLACEAX)
// following bit is used on input to jtcvt only
#define JTNOFUZZX       1   // comparison on legal float conversion should be exact
#define JTNOFUZZ        (((I)1)<<JTNOFUZZX)
// following bit is used inside jtlrep only
#define JTPARENSX       1   // create fully parenthesized output
#define JTPARENS        (((I)1)<<JTPARENSX)
// Next flag must match result.h and VF2 flags, and must be above ZZFLAGBOXATOP
#define JTWILLBEOPENEDX 4   // result of this exec will be opened immediately, so it can contain virtual references to an input to the current verb
     // Note: this flag MUST NOT equal BOX, or BOX<<1, or 1 or 2
#define JTWILLBEOPENED  (((I)1)<<JTWILLBEOPENEDX)
#define JTEMPTYX        5  // in va2, this bit indicates the result is empty
#define JTEMPTY         (((I)1)<<JTEMPTYX)
#define JTRETRYX        6  // in va2, this bit is set to indicate that the current execution is a retry
#define JTRETRY         (((I)1)<<JTRETRYX)

// Next flag must match result.h and VF2 flags, and must be above ZZFLAGBOXATOP
#define JTCOUNTITEMSX   7   // result of this exec will be go into ;, so an item count in m would be helpful
#define JTCOUNTITEMS    (((I)1)<<JTCOUNTITEMSX)

#define JTFLAGMSK       255  // mask big enough to cover all defined flags
#define JTALIGNBDY      8192  // jt is aligned on this boundary - all lower bits are 0 (the value is the size of an SDRAM page, to avoid row precharges while accessing jt)


struct AD {
 union {
  I k;
  A chain;   // used when block is on free chain
  A globalst;  // for local symbol tables (SYMB types), AK points to the active global symbol table when the current sentence started parsing
 } kchain;
 FLAGT flag;
 union {
  I m;  // Multi-use field. (1) For NJA/SMM blocks, size of allocation. (2) for blocks coming out of a COUNTITEMS verb, holds the number of items in the
        // raze of the noun (if the types are identical) (3) for SYMB tables for explicit definitions, the address of the calling symbol table (4) for the block
        // holding the amend offsets in x u} y, the number of axes of y that are built into the indexes in u (5) for name references, the value of jt->modifiercount when the name was last looked up
        // (6) in the return from wordil, holds the number of words if any final NB. is discarded; (7) in the result of indexofsub when called for FORKEY, contains the
        // number of partitions found; (8) in the self block for y L: n and u S: n, the address of the fs block for u; (9) in the call to jtisf (multiple assignment), holds the
        // address of the symbol table being assigned to (10) in the y block internal to pv.c, used for flags (11) in hashtables in x15.c, the number of entries that have been hashed
        // (12) in the faux arg to fixa, pointer to the recursive name-list block (13) in file-lock list and file-number list, the # valid files
  A back; // For VIRTUAL blocks, points to backing block
  A *zaploc;  // For all blocks, AM initially holds a pointer to the place in the tpop stack (or hijacked tpop stack) that points back to the allocated block.  This value is guaranteed
        // to remain valid as long as the block is nonvirtual inplaceable and might possibly return as a result to the parser or result assembly  (in cases under m above, the block cannot become such a result)
} mback;
 union {
  I t;  // type
  A proxychain;  // used when block is on free chain
 } tproxy;
 I c;  // usecount
//  NOTE!! result.h faux cellshape block depends on n, r, and s being in place from here to the end of this struct, with 2 Is from n to s
 I n;  // # atoms - always 1 for sparse arrays
 RANKT r;  // rank
 US h;   // reserved for allocator.  Not used for AFNJA memory
#if BW==64
 UI4 fill;   // On 64-bit systems, there will be a padding word here - insert in case compiler doesn't
#endif
 I s[1];   // shape starts here.  NOTE!! s[0] is always OK to fetch.  We allocate 8 words minimum and s[0] is the last.
};

typedef struct {A a,t;}TA;
typedef A                (*AF)();
typedef UI               (*UF)();
typedef I                (*VF)();  // action verb for atomic dyad
typedef I                (*VA1F)();  // action verb for atomic monad
typedef void             (*VARPSF)();  // action verb for atomic reduce/prefix/suffix routine
typedef B                (*CMP)();    /* comparison function in sort     */
typedef A                  X;
typedef struct {X n,d;}    Q;
typedef struct {D re,im;}  Z;
typedef union {D d;UINT i[2];UI ui;} DI;

#if (SYS & SYS_PC+SYS_MACINTOSH)        /* for use by the session manager  */
typedef S SI;
#else
typedef I SI;
#endif

/* Fields of type A                                                        */

#define AK(x)           ((x)->kchain.k)        /* offset of ravel wrt x           */
#define AKASA(x)        ((x)->kchain.chain)       // the AK field for synthetic self blocks
#define AKGST(x)        ((x)->kchain.globalst)        // global symbol table for this local symbol table
#define AFLAG(x)        ((x)->flag)     /* flag                            */
#define AM(x)           ((x)->mback.m)        /* Max # bytes in ravel            */
#define ABACK(x)        ((x)->mback.back)        /* In virtual noun, pointer to backing block            */
#define AZAPLOC(x)      ((x)->mback.zaploc)    // on allocation, the address of the tstack entry that will free the block
#define AZAPLOCV(x)     ((A*)((x)->s[(x)->r]))    // for virtual blocks,  the address of the tstack entry that will free the block
#define AT(x)           ((x)->tproxy.t)        /* Type; one of the #define below  */
#define AC(x)           ((x)->c)        /* Reference count.                */
#define AN(x)           ((x)->n)        /* # elements in ravel             */
#define AR(x)           ((x)->r)        /* Rank                            */
#define SMMAH           7L   // number of header words in old-fashioned SMM alloc
#define NORMAH          7L   // number of header words in new system
#define AS(x)           ((x)->s)        // Because s is an array, AS(x) is a pointer to the shape, which is in s.  The shape is stored in the fixed position s.

// The following fields are used for private communication between /. and ;. and inside ;. for the fret buffer.
#define CUTFRETCHAIN(x) ((x)->kchain.chain)  // pointer to next block of frets
#define CUTFRETCOUNT(x) ((x)->kchain.k)  // when passed into cut, this is # frets.  Overwritten by CUTFRETCHAIN
#define CUTFRETFRETS(x) ((UC*)((x)->s))   // address of first fret
#define CUTFRETEND(x)   ((x)->n)   // address of last+1 fret

#define AKXR(x)         (SZI*(NORMAH+(x)))
#define WP(t,n,r)       (SMMAH+ r   +(1&&t&LAST0)+(((t&NAME?sizeof(NM):0)+((n)<<bplg(t))+SZI-1)>>LGSZI))  // # I to allocate
#define AKX(x)          AKXR(AR(x))

#define AV(x)           ( (I*)((C*)(x)+AK(x)))  /* pointer to ravel        */
#define BAV(x)          (      (B*)(x)+AK(x) )  /* boolean                 */
#define CAV(x)          (      (C*)(x)+AK(x) )  /* character               */
#define CAV1(x)         (((C*)(x)+AKXR(1)))  // character in non-virtual rank-1 array
#define CAV2(x)         (((C*)(x)+AKXR(2)))  // character in non-virtual rank-2 array
#define UCAV(x)         (     (UC*)(x)+AK(x) )  /* unsigned character      */
#define USAV(x)         ((US*)((C*)(x)+AK(x)))  /* wchar                   */
#define UAV(x)          (     (UC*)(x)+AK(x) )  /* unsigned character      */
#define UIAV(x)         ((UI*)((C*)(x)+AK(x)))  /* unsigned integer      */
#define UI4AV(x)        ((UI4*)((C*)(x)+AK(x)))  /* unsigned 32-bit int      */
#define C4AV(x)         ((C4*)((C*)(x)+AK(x)))  /* literal4                */
#define NAV(x)          ((NM*)((C*)(x)+AKXR(1)))  // name, which is always allocated as rank 1, for some reason
#define IAV(x)          AV(x)                   /* integer                 */
#define IAV0(x)         ((I*)((C*)(x)+AKXR(0)))  // integer in a stack- or heap-allocated atom (rank 0 - used for internal tables)
#define IAV1(x)         ((I*)((C*)(x)+AKXR(1)))  // integer in a stack- or heap-allocated list (rank 1 - used for internal tables that need alignment or need AS[0])
#define BAV0(x)         ( (C*)((C*)(x)+AKXR(0)) )  // Boolean when rank is 0 - fixed position (known to avoid segfault)
#define LXAV0(x)        ( (LX*)((C*)(x)+AKXR(0)) )  // Symbol when rank is 0 - fixed position (for SYMB hash tables).  Note AK() is used in SYMB tables
#define LAV0(x)         ( (L*)((C*)(x)+AKXR(0)) )  // Symbol array when rank is 0 - used for the symbol pool
#define DAV(x)          ( (D*)((C*)(x)+AK(x)))  /* double                  */
#define DAV0(x)         ( (D*)((C*)(x)+AKXR(0)))  // double atom
#define DAV2(x)         ( (D*)((C*)(x)+AKXR(2)) )  // Double when rank is 2 - fixed position (for matrix inversion)
#define ZAV(x)          ( (Z*)((C*)(x)+AK(x)))  /* complex                 */
#define XAV(x)          ( (X*)((C*)(x)+AK(x)))  /* extended                */
#define QAV(x)          ( (Q*)((C*)(x)+AK(x)))  /* rational                */
#define AAV(x)          ( (A*)((C*)(x)+AK(x)))  /* boxed                   */
#define AAV0(x)         ((A*)((C*)(x)+AKXR(0)))  // A block in a stack- or heap-allocated atom (rank 0 - used for internal tables)
#define AAV1(x)         ((A*)((C*)(x)+AKXR(1)))  // A block in a stack- or heap-allocated list (rank 1)
#define VAV(x)          ( (V*)((C*)(x)+AK(x)))  /* verb, adverb, conj      */
#define FAV(x)          ( (V*)((C*)(x)+AKXR(0)) )  // verb, adverb, conj - always at fixed offset
#define PAV(x)          ( (P*)((C*)(x)+AK(x)))  /* sparse                  */
#define SBAV(x)         ((SB*)((C*)(x)+AK(x)))  /* symbol                  */
#define voidAV(x)       ((void*)((C*)(x)+AK(x)))  // unknown
#define BIV0(w) (IAV(w)[0]&(1-((AT(w)&INT)>>(INTX-1))))  // the first (presumably only) value in w, when w is an INT or B01 type

/* Types for AT(x) field of type A                                         */
/* Note: BOOL name conflict with ???; SCHAR name conflict with sqltypes.h  */

// NOTE!! the length of NOUN types must be power-of-2 multiples because of jtamend2

// NOTE: all noun types must be below all parsable non-nouns

#define B01X 0
#define B01             ((I)1L<<B01X)           /* B  boolean                      */
#define B01SIZE         sizeof(B)       // length of 1 atom
#define LITX 1
#define LIT             ((I)1L<<LITX)           /* C  literal (character)          */
#define LITSIZE sizeof(C)
#define INTX 2
#define INT             ((I)1L<<INTX)           /* I  integer                      */
#define INTSIZE sizeof(I)
#define FLX 3
#define FL              ((I)1L<<FLX)           /* D  double (IEEE floating point) */
#define FLSIZE sizeof(D)
#define CMPXX 4
#define CMPX            ((I)1L<<CMPXX)          /* Z  complex                      */
#define CMPXSIZE sizeof(Z)
#define BOXX 5
#define BOX             ((I)1L<<BOXX)          /* A  boxed                        */
#define BOXSIZE sizeof(A)
#define XNUMX 6
#define XNUM            ((I)1L<<XNUMX)          /* X  extended precision integer   */
#define XNUMSIZE sizeof(X)
#define RATX 7
#define RAT             ((I)1L<<RATX)         /* Q  rational number              */
#define RATSIZE sizeof(Q)
#define BITX 8
#define BIT             ((I)1L<<BITX)         /* BT bit boolean                  */
// No size for BIT, since it is fractional
// Bit 9 unused
#define SB01X 10
#define SB01            ((I)1L<<SB01X)        /* P  sparse boolean               */
#define SB01SIZE sizeof(P)
#define SLITX 11
#define SLIT            ((I)1L<<SLITX)        /* P  sparse literal (character)   */
#define SLITSIZE sizeof(P)
#define SINTX 12
#define SINT            ((I)1L<<SINTX)        /* P  sparse integer               */
#define SINTSIZE sizeof(P)
#define SFLX 13
#define SFL             ((I)1L<<SFLX)        /* P  sparse floating point        */
#define SFLSIZE sizeof(P)
#define SCMPXX 14
#define SCMPX           ((I)1L<<SCMPXX)       /* P  sparse complex               */
#define SCMPXSIZE sizeof(P)
#define SBOXX 15
#define SBOX            ((I)1L<<SBOXX)       /* P  sparse boxed                 */
#define SBOXSIZE sizeof(P)
#define SBTX 16
#define SBT             ((I)1L<<SBTX)       /* SB symbol                       */
#define SBTSIZE sizeof(SB)
#define C2TX 17
#define C2T             ((I)1L<<C2TX)      /* C2 unicode (2-byte characters)  */
#define C2TSIZE sizeof(US)
#define C4TX 18
#define C4T             ((I)1L<<C4TX)         /* C4 unicode (4-byte characters)  */
#define C4TSIZE sizeof(C4)
#define XDX 19
#define XD              ((I)1L<<XDX)   // DX extended floating point   used to represent intolerant compare in jtiosc
#define XDSIZE sizeof(DX)
#define XZX 20
#define XZ              ((I)1L<<XZX)   /* ZX extended complex             */
#define XZSIZE sizeof(ZX)

#define LASTNOUNX XZX    // index of last noun bit

// ASGN see below
#define MARKX 22
#define MARK            ((I)1L<<MARKX)     /* I  end-of-stack marker          */
#define MARKSIZE sizeof(I)
#define NAMEX 23
#define NAME            ((I)1L<<NAMEX)    /* NM name                         */
#define NAMESIZE sizeof(C)   // when we allocate a NAME type, the length is the length of the name string
#define SYMBX 24
#define SYMB            ((I)1L<<SYMBX)     /* I  locale (symbol table)        */
#define SYMBSIZE sizeof(LX)
#define CONWX 25
#define CONW            ((I)1L<<CONWX)    /* CW control word                 */
#define CONWSIZE sizeof(CW)
#define ADVX 26
#define ADV             ((I)1L<<ADVX)      /* V  adverb                       */
#define ADVSIZE sizeof(V)
// NOTE: LPAR is set in an ADV value to indicate that the value is nameless, see below
#define VERBX 27
#define VERB            ((I)1L<<VERBX)      /* V  verb                         */
#define VERBSIZE sizeof(V)  // Note: size of ACV in bp() is INTSIZE because the allocation in fdef() is of INTs
// NOTE: VERB must be above all NOUN bits because of CONJCASE
#define LPARX 28
#define LPAR            ((I)1L<<LPARX)    /* I  left  parenthesis            */
// note: LPAR used as flag to cvt() see below
#define LPARSIZE sizeof(I)
// CONJ must be 1 bit below RPAR, with no parsable type (including any flags that might be set, see below) higher than RPAR
#define CONJX 29
#define CONJ            ((I)1L<<CONJX)     /* V  conjunction                  */
#define CONJSIZE sizeof(V)
#define RPARX 30
#define RPAR            ((I)1L<<RPARX)   /* I  right parenthesis            */
#define RPARSIZE sizeof(I)
// NOTE maxtype & maybe others require bit 31 to be 0!!
#define RESVX 31    // reserved so types can be I types
#define RESV    ((I)1<<RESVX)  // used to hold NOUN status sometimes

#define ASGNX 21
#define ASGN            ((I)1L<<ASGNX)     /* I  assignment                   */
#define ASGNSIZE sizeof(I)     // only 1 byte, but all non-DIRECT are fullword multiples
// ** ASGN type can have the following informational bits set along with ASGN
#define ASGNLOCALX      SYMBX     // set for =. (but not when assigning to locative)    aliases with SYMB
#define ASGNLOCAL       ((I)1L<<ASGNLOCALX)     // set for =. (but not when assigning to locative)    aliases with SYMB
#define ASGNTONAME      ((I)1L<<CONWX)     // set when assignment is to name    aliases with CONW
// NOTE: The parser assumes that CONW always means ASGNTONAME, so don't use it in any parseable type (such as NAME, NOUN)
// ** NOUN types can have the following informational bits set
#define NOUNCVTVALIDCT  ((I)1L<<SYMBX)     // Flag for jtcvt arg only: if set, convert only the #atoms given in the parameter   Aliases with SYMB
// ** NAME type can have the following information flags set
#define NAMEBYVALUE     ((I)1L<<SYMBX)     // set if the name is one of x x. m m. etc that is always passed by value, never by name   Aliases with SYMB
// ** BOX type can have the following informational flags set
#define BOXMULTIASSIGN  ((I)1L<<MARKX)     // set for the target of a direct multiple assignment (i. e. 'x y' =.), which is stored as a boxed list whose contents are NAMEs    aliases with MARK
// Restriction: CONW must be reserved for use as ASGNTONAME because of how parser tests for it
// Restriction: MARK must be reserved for use as BOXMULTIASSIGN because of how parser tests for it
// ** NOTE!! bits 28-30 are used in the call to cvt() (arg only) to override the convsion type for XNUMs
#define XCVTXNUMORIDEX  LPARX   // in cvt(), indicates that forced precision for result is present
#define XCVTXNUMORIDE   ((I)1<<XCVTXNUMORIDEX)   // in cvt(), indicates that forced precision for result is present
#define XCVTXNUMCVX     CONJX
#define XCVTXNUMCV      ((I)3<<XCVTXNUMCVX)  // in cvt(), the precision for xnum (if XCVTXNUMORIDE is set)
// ** ADV type can have the following information flag set
#define NAMELESSMODX    LPARX
#define NAMELESSMOD     ((I)1<<NAMELESSMODX)  // set in a modifier to indicate that the value contains no names.  Such values are pushed onto the stack by value to save parsing overhead.
                             // namelessness is detected only when a modifier is assigned, and is supported only for ADV types because of coding details.  It would be nice to support it
                             // for CONJ too, but a nameless conj would be either primitive or explicit, and users shouldn't cover primitives.  This feature is mostly for every/each/inv



// Planned coding to save bits in type
// Uses bits 24-27 eg
// MARK is represented by type of all 0
// Other types are in bits 24-27:
// CONJ   0001
// ADV    0101
// VERB   1101
// ASGN   xy10    x=ASGNLOCAL y=ASGNTONAME
// CONW   0100    must be allocated by GAF, & not be copied, unless ca() is modified to use length not type
// SYMB   1100
// NAME   100v    v=NAMEBYVALUE
// RPAR   0011    must be allocated by GAF, & not be copied, unless ca() is modified to use length not type
// LPAR   1011    must be allocated by GAF, & not be copied, unless ca() is modified to use length not type

#define ANY             -1L
#define SPARSE          (SB01+SINT+SFL+SCMPX+SLIT+SBOX)
#define NUMERIC         (B01+BIT+INT+FL+CMPX+XNUM+RAT+SB01+SINT+SFL+SCMPX)
#define DIRECT          (LIT+C2T+C4T+B01+BIT+INT+FL+CMPX+SBT)
#define JCHAR           (LIT+C2T+C4T+SLIT)
#define NOUN            (NUMERIC+JCHAR+BOX+SBOX+SBT)
#define DENSE           (NOUN&~SPARSE)
#define FUNC            (VERB+ADV+CONJ)
#define RHS             (NOUN+FUNC)
#define IS1BYTE         (B01+LIT)
#define LAST0           (B01+LIT+C2T+C4T+NAME)
// Don't call traverse unless one of these bits is set
#define TRAVERSIBLE     (BOX|VERB|ADV|CONJ|RAT|XNUM|SB01|SINT|SFL|SCMPX|SLIT|SBOX)
// Allow recursive usecount in one of these types
#define RECURSIBLE      (BOX|VERB|ADV|CONJ|RAT|XNUM)
#define RECURSIBLENOUN  (RECURSIBLE&NOUN)
// Modifiers that operate on subarrays do so with virtual blocks, and those blocks may be marked as inplaceable if the backing block is inplaceable.
// The inplaceability applies to the data area, but not necessarily to the block header: if UNINCORPORABLE is set, the header must not be modified (we clone the header in that case)
// For speedy singletons, there is the additional problem that the operation expects always to write a FL value to the result area, which is OK for any
// real block but not for an inplaced virtual block, whose virtual data may be shorter than a FL.  The pure solution would be for the singleton code
// to refrain from modifying a virtual block that is shorter than a FL, but that means we would have to test for it for every arithmetic operation.  Thus
// we take the alternative, which is to not mark a virtual block inplaceable if it is a type shorter than a FL.
//
// BOX type would be OK, as singleton code doesn't touch it and all usecounts are held in the backer, except for the possibility that the backer is recursive and the virtual block isn't.
// Places that check TYPEVIPOK make an exception when the block is going to be processed by each or each2, because those routines are guaranteed not to disturb the boxes, but only
// the first level of contents, and that only when the block is pristine.
//
// Note: arithmetic dyads on bytes have similar issues, because the 8-byte-at-a-time operations may execute outside the cell of the array.  We detect
// those cases inside the atomic-dyad code in va2.c.
#define TYPEVIPOK       (FL+CMPX+SBT+(SZI==SZD?INT:0))
// NOUNSAFE flag
// scaf expunge all the following
#define SAFE(x)         (x)    // type, current block and descendants safe from tstack
#define SAFED(x)        (x)    // type, descendants safe from tstack
#define SAFE0(x)        (x)    // type, current block safe from tstack
#define UNSAFE(x)       (x)   // type, not safe from tstack
#define UNSAFED(x)      (x)   // type, descendants not safe from tstack
#define UNSAFE0(x)      (x)   // type, not safe from tstack

#define TYPESEQ(x,y)    ((x)==(y))  // types are equal, ignoring NOUNSAFE bits
#define TYPESXOR(x,y)    ((x)^(y))  // types are not equal, ignoring NOUNSAFE bits, using full-word logical
#define TYPESNE(x,y)    ((x)!=(y))  // types are equal, ignoring NOUNSAFE bits
#define TYPESLT(x,y)    ((x)<(y))  // type x < type y
#define TYPESGT(x,y)    ((x)>(y)) // type x > type y

#define PARTOFSPEECHEQ(x,y) (((((x)|(RESV&-((x)&NOUN)))^((y)|(RESV&-((x)&NOUN))))&RESV+CONJ+VERB+ADV)==0)  // using RESV to hold NOUN status, verify parts-of-speech the same
#define PARTOFSPEECHEQACV(x,y) ((((x)^(y))&RESV+CONJ+VERB+ADV)==0)  // using RESV to hold NOUN status, verify parts-of-speech the same

// Utility: keep the lowest 1 only
#define LOWESTBIT(x)    ((x)&-(x))

#define POSIFHOMO(s,t)  ( -(((s)^(t))&(BOX|SBT|JCHAR|MARK)) & -(((s)^(t))&(BOX|SBT|NUMERIC|MARK)) )
#define NEGIFHOMO(s,t)  ( ~POSIFHOMO(s,t) )
#define HOMO(s,t)       ( POSIFHOMO(s,t)>=0 )
#define HOMONE(s,t)     HOMO(s,t)
#define STYPE(t)        (((t)&(B01|LIT|INT|FL|CMPX|BOX))<<(SB01X-B01X))
#define DTYPE(t)        (((t)&(SB01|SLIT|SINT|SFL|SCMPX|SBOX))>>(SB01X-B01X))

// Flags in the count field of type A
#define ACINPLACEX      (BW-1)
#define ACINPLACE       ((I)((UI)1<<ACINPLACEX))  // set when this block CAN be used in inplace operations.  Always the sign bit.
#define ACPERMANENTX    (BW-2)
#define ACPERMANENT     ((I)1<<ACPERMANENTX)  // next-to-top bit, set in blocks that should never modify the AC field
#define ACUSECOUNT      (I)1  // lower bits used for usecount
#define ACIPNO(a)       (AC(a)&=~ACINPLACE)
#define ACIPYES(a)      (AC(a)|=ACINPLACE)
#define ACIPISOK(a)     (AC(a)<1)  // OK to modify if INPLACE set - set only when usecount=1
#define ACUC(a)         (AC(a)&(~ACINPLACE))  // just the usecount portion
#define ACUC1           (ACUSECOUNT*1) // <= this is usecount==1; > is UC>1
#define ACINCR(a)       if(!ACISPERM(AC(a)))(AC(a)=(AC(a)+1)&~ACINPLACE)
#define ACX(a)          {AC(a)=ACPERMANENT;}
#define ACISPERM(c)     ((I)((UI)(c)+(UI)(c))<0)  // is PERMANENT bit set?
#define SGNIFPRISTINABLE(c) ((c)+ACPERMANENT)  // sign is set if this block is OK in a PRISTINE boxed noun
// same, but s is an expression that is neg if it's OK to inplace
#define ASGNINPLACESGN(s,w)  (((s)&AC(w))<0 || ((s)&(AC(w)-2))<0 &&jt->assignsym&&jt->assignsym->val==w&&(!(AFLAG(w)&AFRO+AFNVR)||(!(AFLAG(w)&AFRO)&&notonupperstack(w))))  // OK to inplace ordinary operation
#define ASGNINPLACESGNNJA(s,w)  ( ((s)&AC(w))<0 || (((s)&(AC(w)-2))<0||(((s)&(AC(w)-3)&SGNIF(AFLAG(w),AFNJAX))<0))&&jt->assignsym&&jt->assignsym->val==w&&(!(AFLAG(w)&AFRO+AFNVR)||(!(AFLAG(w)&AFRO)&&notonupperstack(w))))  // OK to inplace ordinary operation
// define virtreqd and set it to 0 to start   scaf no LIT B01 C2T etc
// This is used in apip.  We must ALWAYS allow inplacing for NJA types, but for ordinary inplacing we don't bother if the number of atoms of w pushes a over a power-of-2 boundary
// We don't try to help the non-NVR case because NJAs will always be globals and thus have NVR set
#define EXTENDINPLACENJA(a,w)  ( ((AC(a)&(((AN(a)+AN(w))^AN(a))-AN(a)))<0) || ((((AC(a)-2)&(((AN(a)+AN(w))^AN(a))-AN(a)))<0)||(AC(a)==2&&AFLAG(a)&AFNJA))&&((jt->assignsym&&jt->assignsym->val==a&&!(AFLAG(a)&AFRO))||(!jt->assignsym&&(virtreqd=1,!(AFLAG(a)&(AFRO|AFVIRTUAL)))))&&notonupperstack(a))  // OK to inplace ordinary operation

/* Values for AFLAG(x) field of type A                                     */
// the flags defined here must be mutually exclusive with TRAVERSIBLE

#define AFRO            (I)1            /* read only; can't change data    */
#define AFROX           0            /* read only; can't change data    */
#define AFNJAX          1            /* non-J alloc; i.e. mem mapped    */
#define AFNJA           ((I)1<<AFNJAX)
// Note: bit 4 is LABANDONED which is merged here
#define AFNVRX          8
#define AFNVR           ((I)1<<AFNVRX)  // This value is on the parser's execution stack, and must not be freed until it is removed.  Stacked values start as NVR+UNFREED
// the spacing of VIRTUALBOXED->UNIFORMITEMS must match ZZFLAGWILLBEOPENED->ZZCOUNTITEMS
#define AFUNIFORMITEMSX 22     // matches MARK
#define AFUNIFORMITEMS  ((I)1<<AFUNIFORMITEMSX)  // It is known that this boxed array has contents whose items are of uniform shape and type
#define AFNVRUNFREEDX   18
#define AFNVRUNFREED    ((I)1<<AFNVRUNFREEDX)  // This value does NOT need to be freed by the parser, even though it was stacked
#define AFVIRTUALX      17      // matches C2TX
#define AFVIRTUAL       ((I)1<<AFVIRTUALX)  // this block is a VIRTUAL block: a subsequence of another block.  The data pointer points to the actual data, and the
                                 // m field points to the start of the block containing the actual data.  A VIRTUAL block cannot be incorporated into another block, and it
                                 // cannot be assigned, unless it is 'realized' by creating another block and copying the data.  We realize whenever we call ra() on the block,
                                 // except during the EPILOG, where we don't realize the block unless the real block is about to be freed.  Like PERMANENT blocks,
                                 // VIRTUAL blocks are always recursive so that fa() will not recur.  Virtual blocks are always freed from tpop.  Since it cannot be copied or realized,
                                 // the virtual block always has usecount of ACUC1 or ACUC1+ACINPLACE.  EXCEPTION: for the initial assignment to x/y in an explicit
                                 // definition, we allow assigning a virtual block, because we know that the block and its backer are allocated in a higher level
                                 // and can never be freed until the explicit definition finishes.  In this case it is safe to increment the usecount of the virtual block -
                                 // not to ra() the block, which would try to recur.  It is OK to fa() the block on exit or on reassignment, because that will
                                 // just decrement the usecount of the nonrecursive block.
                                 // VIRTUAL blocks are normally not inplaceable (since they are by definition aliased to another block), but the temporary
                                 // UNINCORPORABLE blocks created by partitioning modifers to track cells may be inplaceable, and a virtual block whose backer
                                 // has been abandoned may be marked inplaceable as well.
                                 // NOTE: AFVIRTUALX must be higher than any RECURSIBLENOUN type (for test in result.h)
#define AFUNINCORPABLEX 16      // matches SBTX
#define AFUNINCORPABLE  ((I)1<<AFUNINCORPABLEX)  // (used in result.h) this block is a virtual block used for subarray tracking and must not
                                // ever be put into a boxed array, even if WILLBEOPENED is set, because it changes
#define AFVIRTUALBOXEDX 19   // matches XDX
#define AFVIRTUALBOXED  ((I)1<<AFVIRTUALBOXEDX)  // this block (created in result.h) is an array that is about to be opened, and thus may contain virtual blocks as elements
#define AFPRISTINEX      21  // matches ASGN
#define AFPRISTINE  ((I)1<<AFPRISTINEX)  // meaningful only for BOX type.  This block's contents were made entirely of DIRECT inplaceable or PERMANENT values, and thus can be
   // inplaced by &.> .  If any of the contents are taken out, the PRISTINE flag must be cleared, unless the block is never going to be used again (i. e. is inplaceable).
   // When a VIRTUAL block is created, it inherits the PRISTINE status of its backer; if the block is modified or a value escapes by address, PRISTINE status is cleared in the backer.
   // If a PRISTINE virtual block is realized, the backer must become non-PRISTINE (because its contents are escaping).
   // If a PRISTINE block is incorporated, it must lose PRISTINE status because it is no longer possible to know whether contents may have been fetched while the
   // block was incorporated.
   // MUST BE GREATER THAN ANY DIRECT FLAG
#define AFUPPERTRIX 30      // matches RPAR
#define AFUPPERTRI  ((I)1<<AFUPPERTRIX)  // (used in cip.c) This is an upper-triangular matrix

#define AFAUDITUCX      32   // this & above is used for auditing the stack (you must run stack audits on a 64-bit system)
#define AFAUDITUC       ((I)1<<AFAUDITUCX)    // this field is used for auditing the tstack, holds the number of deletes implied on the stack for the block

// Flags in the AR field of local symbol tables
#define LSYMINUSE 1  // This bit is set in the rank of the original symbol table when it is in use
#define LNAMEADDED LPERMANENT  // Set in rank when a new name is added to the local symbol table.  We transfer the bit from the L flags to the rank-flag
#define LLOCALTABLE 16  // Set in rank of all local symbol tables.  This indicates that the first hashchain holds x/y info and should not be freed as a symbol

#define SFNSIMPLEONLY 1   // to sfn: return simple name only, discarding any locative

#define FIXALOCSONLYLOWEST 4  // to fixa: replace only the first occurrence of u/v in each branch
#define FIXALOCSONLY 8  // to fixa: replace only u/v (IMPLOC)
#define FIXASTOPATINV 16  // to fixa: stop afixing a branch when it gets to a an explicit obverse


typedef struct {I i;US n,go,source;C type;C canend;} CW;

/* control word (always has corresponding token string)                             */
/* type   - as specified in w.h                                            */
/* go     - line number to go to                                           */
/* source - source line number                                             */
/* i      - beginning index of token string                                */
/* n      - length          of token string                                */
// canend - Indicates that the most-recent B-block result can (1) or can't (2) become the result of the running definition.  0 means we don't know yet.


#define DCPARSE  1      /* sentence for parser                                          */
#define DCSCRIPT 2      /* script              -- line()                                */
#define DCCALL   3      /* verb/adv/conj call  -- dbunquote()                           */
#define DCJUNK   4      /* stack entry is stale                                      */

typedef struct DS{      /* 1 2 3                                                        */
 struct DS* dclnk;       /* x x x  link to next stack entry                             */
 A dcy;                 /* x x x  &tokens; text       ; right argument                  */
 I dcn;                 /* x x x  #tokens; line #     ; ptr to symb entry               */
 I dcix;                // x x x  index ; next index  ; line# in exp def being executed, or to be exec next
 I dcj;                 /* x x x  error#; prev index  ; error #                         */
 C dctype;              /* x x x  type of entry (see #define DC*)                       */
 B dcsusp;              /* x   x  1 iff begins a debug suspension                       */
 C dcss;                /*     x  single step code                                      */
 C dcnewlineno;         //     x  set when debug has installed a new line number into dcix
 A dca;                 /*     x  fn/op name                                            */
 A dcf;                 /*     x  fn/op                                                 */
 A dcx;                 /*     x  left argument                                         */
 A dcloc;               /*     x  local symb table (0 if not explicit)                  */
 A dcc;                 /*     x  control matrix   (0 if not explicit)                  */
 I dcm;                 /*   x x        ; script index; # of non-locale part of name    */
 I dcstop;              /*     x  the last stop in this function                        */
} DST;

typedef DST* DC;


typedef struct {I e,p;X x;} DX;
                                /* for the p field in DX */
#define DXIPREC         ((I)-1) /* infinite precision    */
#define DXINF           ((I)-2) /* _  infinity           */
#define DXMINF          ((I)-3) /* __ negative infinity  */

/* extended floating point                                                 */
/* e - exponent                                                            */
/* p - precision & other codes                                             */
/*        +ve   # of significant digits                                    */
/*        _1    infinite precision (with trailing 0s)                      */
/*        _2    infinity _                                                 */
/*        _3    negative infinity __                                       */
/* x - mantissa                                                            */
/*        least significant digit first                                    */
/*        decimal point after last digit                                   */

#define SYMLINFO 0  // index of LINFO entry
#define SYMLINFOSIZE 1     // Number of symbol-table entries that DO NOT contain symbol chains, but instead are LINFO entries

typedef struct {A name,val;US flag;S sn;LX next;} L;

/* symbol pool entry                         LINFO entry (named/numbered)      */
//-------------------------------------------------------------------------
/* name - name on LHS of assignment          locale name                    */
/* val  - value                              locale search path              */
// flag - various flags                      locale flags                 
/* sn   - script index                              not used                   */
/* next - index of successor in hash list or 0      mot used                  */

// FOR EXECUTING LOCAL SYMBOL TABLES: AK() points to the active global symbol table, AM() points to the calling local symbol table.
// In all local symbol tables, the first 'hashchain' has the symbol offsets of x/y

#define LCH             (I)1            /* changed since last exec of 4!:5 */
#define LINFO           (I)4            /* locale info                     */
#define LPERMANENT      (I)8            // This is a permanent entry in a local symbol table; don't delete, just leave val=0
#define LWASABANDONEDX  4
#define LWASABANDONED   ((I)1<<LWASABANDONEDX)  // set if the name was assigned from an abandoned value, and we DID NOT raise the usecount of the value (we will have changed INPLACE to ACUC1, though).
                                    // when the name is reassigned or deleted, we must refrain from fa(), and if the value still has AC=ACUC1, we should revert it to inplaceable so that the parser will free it
                                    // immediately
                                    // This value passes into AFLAGS and must not overlap anything there
#define LHASNAME        (I)32      // name is nonnull - this value is not used internally; it appears in the result of 18!:31
#define LHASVALUE       (I)64     // value is nonnull - this value is not used internally; it appears in the result of 18!:31
// in LINFO entry
#define LMOD            (I)1          // table has had new entries added (used for local symbol tables only)


// Definition of callstack

typedef struct {
 I type;  // type of entry, flagged per below
 void *value;  // locale or name, depending on the type
} LS;
#define CALLSTACKPOPLOCALE 2  // value is jt->global that must be restored after function returns
#define CALLSTACKPOPFROM 4  // value is jt->global that must be modified in the caller of this function also
#define CALLSTACKCHANGELOCALE 8  // value is jt->global that was changed within execution of this name
#define CALLSTACKPOPLOCALEFIRST 16  // set in the POPLOCALE that is added when the first POPFROM is seen
#define CALLSTACKPUSHLOCALSYMS 32  // value is jt->locsyms that must be restored
#define CALLSTACKDELETE 256  // the given locale must be deleted, and this is the earliest place on the stack that refers to it

// Add an entry to the call stack, and increment the index variable
#define pushcallstack(i,t,v) (jt->callstack[i].type=(t), jt->callstack[i].value=(v), ++i)
#define pushcallstack1(t,v) {ASSERT(jt->callstacknext<jt->fcalln,EVSTACK);  pushcallstack(jt->callstacknext,(t),(v));}
#define pushcallstack1d(t,v) {FDEPDEC(d); ASSERT(jt->callstacknext<jt->fcalln,EVSTACK);  pushcallstack(jt->callstacknext,(t),(v));}


typedef struct{UI4 hash;I4 bucket;I bucketx;UC m;C flag,s[1];} NM;

/* hash: hash for  non-locale part of name                                 */
// bucket: (for local simple names) the index of the hash chain for this symbol when viewed as a local
//   0 if chain index not known or name is a locative
// bucketx: (for local simple names, only if bucket!=0) the number of chain entries to discard before
//   starting name search.  If negative, use one's complement and do not bother with name search - symbol-table entry
//   is guaranteed to be at that position
//   (for direct locatives) the hash of the locative - if numbered, the number itself.
//   (for indirect locatives) hash of the last indirect name
//   (for locale names in SYMLINFO of a numbered locale) the locale number 
// m:    length of non-locale part of name note 255-byte limit! (AN holds the length of the entire name including the locative)
/* s:    string part of full name (1 to ?? characters, including locale of assignment if given)           */

#define NMLOC           1       /* direct   locale abc_lm_                 */
#define NMILOC          2       /* indirect locale abc__de__fgh ...        */
#define NMDOT           4       /* one of the names m. n. u. v. x. y.      */
#define NMXY            8       // x/y, which must have NAMEBYVALUE set
#define NMIMPLOC        16      // this NM block is in u./v.


typedef struct {I a,e,i,x;} P;

/* value fields of sparse array types                                      */
/* fields are offsets from beginning of the P struct                       */
/* a: sparse axes                                                          */
/* e: sparse element                                                       */
/* i: index matrix, columns correspond to a                                */
/* x: value cells corresponding to rows of i                               */

#define SPA(p,a)        ((A)((p)->a+(C*)(p)))  // a is one of aeix; result is A pointer for that component
#define SPBV(p,a,v,x)      {RZ(v = (x)); INCORP(v); (p)->a=(C*)v-(C*)(p);}  // store x into component (a); return if x is 0.  a is one of aeix.  Result in v
#define SPB(p,ZWa,x)      {A ZWo = (x); SPBV((p),ZWa,ZWo,(x))}  // store x into component (a); return if x is 0.  a is one of aeix

// Header for hashtables used in i.
// This sits at the beginning of the allocated block, holding info about the stored values
typedef struct {
 I datasize;   // number of bytes in the data area
 I hashelelgsize;  // lg(size of a hashed element)
 UI currentlo;   // the lowest position in the hashtable of the current allocation.
 UI currenthi;   // the highest position+1 of the current allocation.
 UI currentindexofst;   // the value in the hashtable that the minimum value in the input will map to
 UI currentindexend;    // the highest value that can possibly be written, +1
 UI previousindexend;  // All positions from 0 to currenthi are known to be less than currentindexend.
             // Positions from currenthi to the end are known to be less than previousindexend.
 UI invalidlo;   // the start of the area that does not have constrained values because it was used for a bit table (as an index into hashtable, rounded up to multiple of I for endian reasons)
 UI invalidhi;   // the end+1 of the area used for a bit table  (as an index into hash table, rounded up to multiple of I)
 I datamin;  // (for small-range use) minimum value in the data
 UI datarange;  // (for small-range use) range+1 of the data
 // 11 words here; 7 words of header (we allocate no shape); 2 words of memory-allocation header; so this block is 20 words after the
 // memory allocation, and thus is on the same 256-bit boundary as the allocation.
 union {   // We index into the data with varying strides, depending on the range of the data
  uint8_t      UC [1];  // cannot have union of empty vectors
  uint16_t     US [1];
  uint32_t       UI4[1];
  uint64_t UI [1];
 } data;
} IH;
#define IHAV(x)         ((IH*)((C*)(x)+AK(x)))  //  how to refer to the header area

// Return value from condrange
typedef struct {
 I min;  // smallest value found
 I range;  // max+1-min, or 0 if range exceeds max given
} CR;

/* performance monitoring stuff */

typedef struct{
 A name;                /* verb/adverb/conjunction name                    */
 A loc;                 /* locale name                                     */
 I lc;                  /* line number (-1 for entry; -2 for exit)         */
 I s;                   /* space                                           */
 I t[2];                /* time                                            */
 C val;                 /* valence: 1 or 2                                 */
 C unused[3];           /* padding                                         */
} PM;

#define PMCOL  6        /* # of fields in PM                               */

typedef struct{
 I n;                   /* maximum number of records                       */
 I i;                   /* index of next record to be written              */
 I s;                   /* initial bytesmax value                          */
 B rec;                 /* what to record (0 entry & exit; 1 all)          */
 B trunc;               /* what to do on overflow (0 wrap; 1 truncate)     */
 B wrapped;             /* 1 iff wrapping has happened                     */
 C unused[1];           /* padding                                         */
} PM0;


/* each unique symbol has a row in jt->sbu                                 */
/* a row is interpreted per SBU                                            */
/* for best results make sizeof(SBU) a multiple of sizeof(I)               */
 
typedef struct{
 I  i;                  /* index into sbs                                  */
 I  n;                  /* length                                          */
 UI h;                  /* hash value                                      */
 I  color;              /* binary tree: color                              */
 I  parent;             /* binary tree: index of parent                    */
 I  left;               /* binary tree: index of left  child               */
 I  right;              /* binary tree: index of right child               */
 I  order;              /* order number                                    */
 I  down;               /* predecessor in ordering                         */
 I  up;                 /* successor   in ordering                         */
 I  flag;               /* bit flags                                       */
} SBU;

#define SBC2  1         /* 1 iff 2-byte character                          */
#define SBC4  2         /* 2 iff 4-byte character                          */



typedef struct {AF valencefns[2];A fgh[3];union { D lD; void *lvp[2]; I lI; I4 lI4[4]; I lclr[2]; AF lfns[2]; struct {I parm; AF func;} lpf; } localuse;I4 flag;UI4 flag2; RANK2T lrr; RANKT mr; C id; C lc;} V;  // two cachelines exactly in 64-bit
// the localuse fields are not freed or counted for space, as the f/g/h fields are.  It is for local optimizations only.  We put if first so that the rest of
// the block, which is used more, is in a single cacheline.  Local uses are:
// for ATOMIC ops, lvp[] is pointer to the VA/UA block for adocv [dyad then monad]
// for name references, lvp[0] is pointer to last resolution
// for FIT conj, the CCT data
// for RANK conj, lI4[0-2] has the signed ranks
// for Fold final operator, lfns[1] has pointer to the dyadic EP of the handler (xdefn or unquote)
// For cyclic iterators, lI has the index of the next gerund to execute
// for u;.n where n is nonzero, lvp[0] holds n.  u/. also goes through this code
// for reductions (u/ u/\ u/\.) lvp[1] points to the VA block for u
// for u&.[:]v, lvp[0] points to the verb whose inverse is needed
// for x <;.0 y  and  x (<;.0~ -~/"2)~ y, lpf.parm is ~0 for first, 0 for second, and func points to failover routine
// for dyads ; (,<) ,&[:]<  lclr[0] indicates which function

// lc is a local-use byte.  Used in atomic dyads to indicate which singleton function to execute
// in the derived function from fold, lc has the original id byte of the fold op

// id must be in the last word  so that we can use validitymask to point to it


#define ID(f)  FAV(AT(f?f:(A)(validitymask+12))&FUNC?f:(A)validitymask)->id  // can be branchless, if compiler can manage it
#define VFLAGNONE 0L
#define VRTNNONE ((A)0)
  
                                        /* type V flag values              */
// bits 0-7 are used in comparison compounds to encode the type of compound, see vcompsc.c
// for other types, they are defined as follows:
#define VFATOPL         JTINPLACEW     // (in forks and v0`v1`v2) f/v0 is x@[, so OK to inplace w arg of h
#define VFATOPR         JTINPLACEA     // (in forks and v0`v1`v2) f/v0 is x@], so OK to inplace a arg of h
#define VFHKLVLDECX     0   // (in (compare L.) hooks) set for > and <: to indicate increment of x needed before levelle
#define VFHKLVLDEC      (((I)1)<<VFHKLVLDECX)
#define VFHKLVLGTX      1   // (in (compare L.) hooks) set for < and <: to indicate complement of result of levelle needed
#define VFHKLVLGT       (((I)1)<<VFHKLVLGTX)
#define VFSCANIRSX     0   // (in u/\) set if u supports IRS2
#define VFSCANIRS      (((I)1)<<VFSCANIRSX)
#define VFUNDERHASINVX  0  // (in u&.[:]v) set if h has the inverse already added
#define VFUNDERHASINV      (((I)1)<<VFUNDERHASINVX)
#define VFATOPPOLYX  0  // (in p.) the function to run after p.  0=none, 1=^
#define VFATOPPOLY      (((I)3)<<VFATOPPOLYX)
#define VFATOPPOLYNONE  0
#define VFATOPPOLYEXP  1
#define VFKEYSLASHTX  0  // (in f/.) set if f is u/ where u is one of + <. >., indicating which types are OK for atoms (can't handle int ovfl)
#define VFKEYSLASHT      (((I)(2*FL-1))<<VFKEYSLASHTX)
#define VFKEYSLASHFX  (FLX+1)  // (in f/.) function coded for, 0=<. 1=>. 2=+
#define VFKEYSLASHF      (((I)3)<<VFKEYSLASHFX)


// bits 8 and above are available for all functions:
#define VGERLX          8
#define VGERL           (((I)1)<<VGERLX)          /* gerund left  argument           */
#define VGERR           (I)512          /* gerund right argument           */
#define VTAYFINITE      (I)1024         /* t. finite polynomial            */
#define VIRS1           (I)2048         /* 11 monad has integral rank support */
#define VIRS2X          12
#define VIRS2           (((I)1)<<VIRS2X)         /* 12 dyad  has integral rank support */
#define VFLR            (I)0x2000         /* function is <.@g                */
#define VCEIL           (I)0x4000       /* function is >.@g                */
#define VMOD            (I)0x8000        /* function is m&|@g               */
#define VLOCK           (I)0x10000        /* function is locked              */
#define VNAMED          (I)0x20000       /* named explicit defn             */
#define VFIX            (I)0x40000       /* f. applied                      */
#define VXOPR           (I)0x80000       /* : defn with u. and x.           */
#define VXOP            (I)0x100000      /* : defn derived fn               */
#define VXOPCALL        (I)0x200000      /* : defn derived fn call          */
#define VTRY1           (I)0x400000      /* monad contains try.             */
#define VTRY2           (I)0x800000      /* dyad  contains try.  must be just above VTRY1           */
#define VDDOP           (I)0x1000000     /* 24 derived from a derived operator */
#define VJTFLGOK1X    25    // 25 monad can handle flags in jt
#define VJTFLGOK1     (((I)1)<<VJTFLGOK1X)
#define VJTFLGOK2X    26    // 26 dyad can  handle flags in jt
#define VJTFLGOK2     (((I)1)<<VJTFLGOK2X)
#define VASGSAFEX     27
#define VASGSAFE      (((I)1)<<VASGSAFEX)     // does not alter locale/path
#define VISATOMIC1      ((I)(1L<<28))     // processes each atom individually (logically rank 0, but handles all ranks)
#define VISATOMIC2      ((I)(1L<<29))    // dyad is atomic.  localuse will point to the VA entry for the verb
#define VFUSEDOK2  ((I)(1L<<30))    // this block can be executed by passing in another block (containing rank) whose fgh[0] points to the native block for this primitive

// bits in flag2:
#define VF2NONE 0
// bit 0 unused
#define VF2BOXATOP1X      1   // This verb is one of  <  <@f   <@:f   <&f   <&:f    f&.>  f&.:>
#define VF2BOXATOP1     ((I)(((I)1)<<VF2BOXATOP1X))
#define VF2BOXATOP2X      2   // This verb is one of  <@f   <@:f   f&.>  f&.:>
#define VF2BOXATOP2     ((I)(((I)1)<<VF2BOXATOP2X))
// next flag must be same as JTWILLBEOPENED
#define VF2WILLOPEN1X      4   // This verb will open y as its first act.  Monad case only
#define VF2WILLOPEN1       ((I)(((I)1)<<VF2WILLOPEN1X))
// must leave a gap for WILLBEOPENED in result.h
#define VF2ISCCAPX        5   // flags (if any) came from ([: g h) rather than f@:g
#define VF2ISCCAP         ((I)(((I)1)<<VF2ISCCAPX))
// next flag must be same as JTCOUNTITEMS
#define VF2USESITEMCOUNT1X 7   // This verb can make use of an item count stored in m.  Monad case only
#define VF2USESITEMCOUNT1  ((I)(((I)1)<<VF2USESITEMCOUNT1X))
// must leave a gap for COUNTITEMS in result.h
// next 3 flags must be spaced from VF2BOXATOP? to match spacing in ZZFLAGS
#define VF2ATOPOPEN1X     8   // This verb is one of  > @> &> &.>
#define VF2ATOPOPEN1     ((I)(((I)1)<<VF2ATOPOPEN1X))
#define VF2ATOPOPEN2WX    9   // This verb is one of  &> &.>
#define VF2ATOPOPEN2W     ((I)(((I)1)<<VF2ATOPOPEN2WX))
#define VF2ATOPOPEN2AX    10   // This verb is one of  &> &.>
#define VF2ATOPOPEN2A     ((I)(((I)1)<<VF2ATOPOPEN2AX))
#define VF2RANKATOP1X     11   // set if this verb starts out with rank loop and thus can be subsumed into a higher rank loop
#define VF2RANKATOP1     ((I)(((I)1)<<VF2RANKATOP1X)) 
#define VF2RANKATOP2X     12   // set if this verb starts out with an outer rank loop.  " @ & &. and not special-cased
#define VF2RANKATOP2     ((I)(((I)1)<<VF2RANKATOP2X))
#define VF2RANKONLY1X     13   // set if this verb is u"r, not special-cased (i. e. function points to rank processing).  The rank may be subsumed into a higher rank before we see arguments.
#define VF2RANKONLY1     ((I)(((I)1)<<VF2RANKONLY1X)) 
#define VF2RANKONLY2X     14
#define VF2RANKONLY2     ((I)(((I)1)<<VF2RANKONLY2X))
// Next 4 flags must be spaced so they can shift down to WILLOPEN1 and COUNTITEMS1
#define VF2WILLOPEN2WX      15   // This verb will open y as its first act.  Monad case only
#define VF2WILLOPEN2W       ((I)(((I)1)<<VF2WILLOPEN2WX))
#define VF2WILLOPEN2AX      16   // This verb will open y as its first act.  Monad case only
#define VF2WILLOPEN2A       ((I)(((I)1)<<VF2WILLOPEN2AX))
#define VF2USESITEMCOUNT2WX 18   // This verb can make use of an item count stored in m.  Monad case only
#define VF2USESITEMCOUNT2W  ((I)(((I)1)<<VF2USESITEMCOUNT2WX))
#define VF2USESITEMCOUNT2AX 19   // This verb can make use of an item count stored in m.  Monad case only
#define VF2USESITEMCOUNT2A  ((I)(((I)1)<<VF2USESITEMCOUNT2AX))

// layout of primitive, in the primtbl.  It is a memory header (shape 0) followed by a V
typedef struct {I memhdr[AKXR(0)/SZI]; union { V primvb; I primint; } prim; } PRIM;  // two cachelines exactly in 64-bit

// Info for calling an atomic verb
typedef struct {VF f;I cv;} VA2;  // for dyads
typedef struct {VA1F f;I cv;} VA1;  // for monads
typedef struct {VARPSF f;I cv;} VARPS;  // for reduce/prefix/suffix

typedef struct {I nprec; VARPS actrtns[];} VARPSA;
typedef struct {VA2 p2[13];VARPSA *rps;} VA;
typedef struct {VA1 p1[6];} UA;


typedef struct {DX re;DX im;} ZX;

/* extended complex                                                        */
/* re - real part                                                          */
/* im - imaginary part                                                     */


// parser stack - this MUST have size equal a power of 2!!
typedef struct {
  // Because the parse decode looks mostly at pt, make that the first thing so that it is always aligned to the beginning
  // of whatever block is usd to copy one stack element to another.
 UI4 pt;  // parser type: code for one of the 9 variants recognized.
 UI4 t;  // token number for this block
 A a;  // pointer to block
} PSTK;

// stack frame used by the parser
 typedef struct{
  PSTK* parserstkbgn;     // &start of parser stack
  PSTK* parserstkend1;    // &end+1 of parser stack
  A    *parserqueue;   // for error purposes: words of the sentence being parsed
  US   parserqueuelen;  // number of words in queue
  US   parsercurrtok;   // the token number of the word to flag if there is an error
  US  nvrtop;           /* top of nvr stack; # valid entries               */
  US  nvrotop;          // previous top of nvr stack
 } PFRAME;  // these are stacked en bloc
